from reco3d.resources.basic_resources import Resource
from reco3d.converters.larpix_converters import (LArPixHDF5Converter, LArPixSerialConverter)
import reco3d.tools.python as reco3d_pytools
import reco3d.types as reco3d_types

class LArPixSerialDataResource(Resource):
    '''
    This class handles reading in and sorting HDF5 files generated by the dat2h5.py script
    Currently, this class only supports reading in Hits (as that is all that the serial files contain)
    The read queue is by default sorted according to the Hit attribute `ts`
    '''
    req_opts = Resource.req_opts + []
    default_opts = reco3d_pytools.combine_dicts(\
        Resource.default_opts, { 'read_queue_length' : 2000, # length of sorted read queue
                                 'sort_read_queue' : True, # sort objects in read queue?
                                 'sort_field' : 'ts' # object attribute to sort by
                                 })

    def config(self): # Resource method
        ''' Initialize converter and options '''
        super().config()

        self.converter = LArPixSerialConverter(self.options.get('LArPixSerialConverter'))
        self.eof_reached = False
        self.read_queue_length = self.options['read_queue_length']
        self.sort_field = self.options['sort_field']
        self.sort_read_queue = self.options['sort_read_queue']
        self._read_queue[reco3d_types.Hit] = []

    def start(self): # Resource method
        ''' Open file and queue up first data '''
        super().start()

        self.converter.open()

        for dtype in self.read_queue_dtypes():
            idx = 0
            while idx < self.read_queue_length:
                new_data = self.converter.read(dtype)
                if new_data is None:
                    self.eof_reached = True
                    break
                self._read_queue[dtype] += [new_data]
                idx += 1
            if self.sort_read_queue:
                self._read_queue[dtype].sort(key=operator.attrgetter(self.sort_field))

    def run(self): # Resource method
        ''' Read in next data '''
        super().run()

        for dtype in self.read_queue_dtypes():
            if len(self._read_queue[dtype]) < self.read_queue_length:
                idx = 0
                while idx < self.read_queue_length - len(self._read_queue[dtype]):
                    new_data = self.converter.read(dtype)
                    if new_data is None:
                        self.eof_reached = True
                        break
                    self._read_queue[dtype] += [new_data]
                if self.sort_read_queue:
                    self._read_queue[dtype].sort(key=operator.attrgetter(self.sort_field))

    def continue_run(self): # Resource method
        ''' Continue as long as the EOF has not been reached or there is still data in the read queue '''
        return not self.eof_reached or any([self._read_queue[dtype] for dtype in self.read_queue_dtypes()])

    def cleanup(self): # Resource method
        ''' Close converter '''
        self.converter.close()

class LArPixDataResource(Resource):
    '''
    This class handles queuing / storing / accessing data for the LArPix analysis files
    '''
    req_opts = Resource.req_opts + []
    default_opts = reco3d_pytools.combine_dicts(\
        Resource.default_opts, { 'write_queue_length' : 100 # length of write queue before flushing to file
                                 })

    def config(self): # Resource method
        ''' Initialize converter and options '''
        super().config()

        self.converter = LArPixHDF5Converter(self.options.get('LArPixHDF5Converter'))
        self.write_queue_length = self.options['write_queue_length']

    def start(self): # Resource method
        ''' Open converter '''
        super().start()

        self.converter.open()

    def run(self): # Resource method
        ''' Clear stack and flush buffer '''
        super().run()

        for dtype in self._write_queue.keys():
            if len(self._write_queue[dtype]) > self.write_queue_length:
                self.flush_write_buffer(dtype)

    def finish(self): # Resource method
        ''' Flush all write buffers '''
        super().finish()

        for dtype in self._write_queue.keys():
            self.flush_write_buffer(dtype)

    def cleanup(self): # Resource method
        ''' Close converter '''
        super().cleanup()

        self.converter.close()

    def flush_write_buffer(self, dtype):
        ''' Flush write buffer of data type '''
        write_success = True
        for obj in self._write_queue[dtype]:
            write_success = self.converter.write(obj) and write_success
        if not write_success:
            self.logger.error('write failure - could not flush write buffer')
        else:
            self._write_queue[dtype] = []

class LArPixCalibrationDataResource(Resource):
    pass
